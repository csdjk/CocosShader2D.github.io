[1,["121bf259-eddf-4758-bb69-4df53b851451"],["_effectAsset"],[["cc.EffectAsset",["_name","shaders","techniques"],0],["cc.Material",["_name","_props","_states","_defines"],-1]],[[0,0,1,2,4],[1,0,1,2,3,5]],[[[[0,"../Shaders/GlitchArt",[{"hash":3347155826,"name":"../Shaders/GlitchArt|vs|fs","blocks":[{"name":"PostUBO","stageFlags":17,"binding":0,"members":[{"name":"texSize","type":16,"count":1},{"name":"params","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"inputTexture","type":28,"count":1,"stageFlags":17,"binding":1,"defines":[]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":6,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":7,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBiasAndProbeId","format":44,"isInstanced":true,"location":11,"defines":["USE_INSTANCING"]},{"name":"a_reflectionProbeData","format":44,"isInstanced":true,"location":12,"defines":["USE_INSTANCING","CC_USE_REFLECTION_PROBE"]},{"name":"a_sh_linear_const_r","format":44,"isInstanced":true,"location":13,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_g","format":44,"isInstanced":true,"location":14,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_b","format":44,"isInstanced":true,"location":15,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_vertexId","format":11,"location":16,"defines":["CC_USE_MORPH"]}],"fragColors":[{"name":"fragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"descriptors":[{"rate":0,"blocks":[],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":1,"blocks":[{"name":"PostUBO","stageFlags":17,"binding":0,"members":[{"name":"texSize","type":16,"count":1},{"name":"params","type":16,"count":1}],"defines":[]}],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":2,"blocks":[],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":3,"blocks":[{"name":"CCGlobal","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_time","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_screenSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nativeSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_probeInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_debug_view_mode","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCamera","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_matView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_cameraPos","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_surfaceTransform","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_screenScale","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_exposure","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitDir","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientSky","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientGround","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogBase","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogAdd","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nearFar","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_viewPort","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]}],"samplerTextures":[{"name":"inputTexture","type":28,"count":1,"stageFlags":17,"binding":1,"defines":[]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]}],"glsl3":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nfloat saturate(float value) { return clamp(value, 0.0, 1.0); }\nvec2 saturate(vec2 value) { return clamp(value, vec2(0.0), vec2(1.0)); }\nvec3 saturate(vec3 value) { return clamp(value, vec3(0.0), vec3(1.0)); }\nvec4 saturate(vec4 value) { return clamp(value, vec4(0.0), vec4(1.0)); }\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define REFLECTION_PROBE_TYPE_BLEND 3\n#define REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX 4\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_POINT 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n#ifndef CC_SURFACES_DEBUG_VIEW_SINGLE\n  #define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#endif\n#ifndef CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  #define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#endif\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_USE_REFLECTION_PROBE || CC_RECEIVE_SHADOW\n    #if CC_RECEIVE_SHADOW\n    #endif\n    in vec4 a_localShadowBiasAndProbeId;\n  #endif\n  #if CC_USE_REFLECTION_PROBE\n    in vec4 a_reflectionProbeData;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n    in vec4 a_sh_linear_const_r;\n    in vec4 a_sh_linear_const_g;\n    in vec4 a_sh_linear_const_b;\n  #endif\n#endif\n#if CC_USE_MORPH\n    in float a_vertexId;\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_probeInfo;\n  mediump vec4 cc_debug_view_mode;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform PostUBO {\n  vec4 texSize;\n  vec4 params;\n};\nuniform sampler2D inputTexture;\n#define _ScanLineJitter params.x\n#define _ColorDrift params.y\n#define _VerticalJump params.z\n#define _HorizontalShake params.w\nout vec2 v_uv;\nout vec4 v_scanLineJitter;\nout vec4 v_colorDrift;\nvoid main() {\n  StandardVertInput In;\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  In.position.xy = cc_cameraPos.w == 0.0 ? vec2(In.position.xy.x, -In.position.xy.y) : In.position.xy;\n  gl_Position = In.position;\n  v_uv = a_texCoord;\n  float time_20 = cc_time.x * 0.05;\n  float sl_thresh = saturate(1.0 - _ScanLineJitter * 1.2);\n  float sl_disp = 0.002 + pow(_ScanLineJitter, 3.0) * 0.05;\n  float verticalJump = _VerticalJump;\n  float verticalJumpTime = time_20 * verticalJump;\n  float horizontalShake = _HorizontalShake * 0.2;\n  float colorDrift = _ColorDrift * 0.04;\n  float time = time_20 * 606.11;\n  v_scanLineJitter = vec4(sl_disp, sl_thresh, abs(verticalJump), verticalJumpTime);\n  v_colorDrift = vec4(colorDrift, horizontalShake, time, time_20);\n}","frag":"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_probeInfo;\n  mediump vec4 cc_debug_view_mode;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#ifndef COMMON_INCLUDE\n#define COMMON_INCLUDE\n#ifndef HLSL_FUNCTIONS_GLSL\n#define HLSL_FUNCTIONS_GLSL\n#define lerp mix\n#define frac fract\n#define fmod mod\n#define float2 vec2\n#define float3 vec3\n#define float4 vec4\n#define float2x2 mat2\n#define float3x3 mat3\n#define float4x4 mat4\n#define _ScreenParams cc_screenSize;\n#endif\nfloat nrand(float x, float y) {\n  return fract(sin(dot(vec2(x, y), vec2(12.9898, 78.233))) * 43758.5453);\n}\n#endif\n#ifndef COLOR_INCLUDE\n#define COLOR_INCLUDE\n#ifndef HLSL_FUNCTIONS_GLSL\n#define HLSL_FUNCTIONS_GLSL\n#define lerp mix\n#define frac fract\n#define fmod mod\n#define float2 vec2\n#define float3 vec3\n#define float4 vec4\n#define float2x2 mat2\n#define float3x3 mat3\n#define float4x4 mat4\n#define _ScreenParams cc_screenSize;\n#endif\n#endif\n#ifndef HLSL_FUNCTIONS_GLSL\n#define HLSL_FUNCTIONS_GLSL\n#define lerp mix\n#define frac fract\n#define fmod mod\n#define float2 vec2\n#define float3 vec3\n#define float4 vec4\n#define float2x2 mat2\n#define float3x3 mat3\n#define float4x4 mat4\n#define _ScreenParams cc_screenSize;\n#endif\nin vec2 v_uv;\nin vec4 v_scanLineJitter;\nin vec4 v_colorDrift;\nlayout(std140) uniform PostUBO {\n  vec4 texSize;\n  vec4 params;\n};\nuniform sampler2D inputTexture;\nlayout(location = 0)out vec4 fragColor;\nvoid main() {\n  float sl_disp = v_scanLineJitter.x;\n  float sl_thresh = v_scanLineJitter.y;\n  float verticalJump = v_scanLineJitter.z;\n  float verticalJumpTime = v_scanLineJitter.w;\n  float colorDrift = v_colorDrift.x;\n  float horizontalShake = v_colorDrift.y;\n  float time = v_colorDrift.z;\n  float time_20 = v_colorDrift.w;\n  float u = v_uv.x;\n  float v = v_uv.y;\n  float jitter = nrand(v, time_20) * 2.0 - 1.0;\n  jitter *= step(sl_thresh, abs(jitter)) * sl_disp;\n  float jump = mix(v, fract(v + verticalJumpTime), verticalJump);\n  float shake = (nrand(time_20, 2.0) - 0.5) * horizontalShake;\n  float drift = sin(jump + time) * colorDrift;\n  vec4 src1 = texture(inputTexture, fract(vec2(u + jitter + shake, jump)));\n  vec4 src2 = texture(inputTexture, fract(vec2(u + jitter + shake + drift, jump)));\n  vec4 color = vec4(src1.r, src2.g, src1.b, src1.a);\n  fragColor = vec4(color.rgb,1);\n}"},"glsl1":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nfloat saturate(float value) { return clamp(value, 0.0, 1.0); }\nvec2 saturate(vec2 value) { return clamp(value, vec2(0.0), vec2(1.0)); }\nvec3 saturate(vec3 value) { return clamp(value, vec3(0.0), vec3(1.0)); }\nvec4 saturate(vec4 value) { return clamp(value, vec4(0.0), vec4(1.0)); }\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define REFLECTION_PROBE_TYPE_BLEND 3\n#define REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX 4\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_POINT 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n#ifndef CC_SURFACES_DEBUG_VIEW_SINGLE\n  #define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#endif\n#ifndef CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  #define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#endif\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_USE_REFLECTION_PROBE || CC_RECEIVE_SHADOW\n    #if CC_RECEIVE_SHADOW\n    #endif\n    attribute vec4 a_localShadowBiasAndProbeId;\n  #endif\n  #if CC_USE_REFLECTION_PROBE\n    attribute vec4 a_reflectionProbeData;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n    attribute vec4 a_sh_linear_const_r;\n    attribute vec4 a_sh_linear_const_g;\n    attribute vec4 a_sh_linear_const_b;\n  #endif\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n#endif\nuniform highp vec4 cc_time;\nuniform highp vec4 cc_cameraPos;\n      uniform vec4 params;\nuniform sampler2D inputTexture;\n#define _ScanLineJitter params.x\n#define _ColorDrift params.y\n#define _VerticalJump params.z\n#define _HorizontalShake params.w\nvarying vec2 v_uv;\nvarying vec4 v_scanLineJitter;\nvarying vec4 v_colorDrift;\nvoid main() {\n  StandardVertInput In;\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  In.position.xy = cc_cameraPos.w == 0.0 ? vec2(In.position.xy.x, -In.position.xy.y) : In.position.xy;\n  gl_Position = In.position;\n  v_uv = a_texCoord;\n  float time_20 = cc_time.x * 0.05;\n  float sl_thresh = saturate(1.0 - _ScanLineJitter * 1.2);\n  float sl_disp = 0.002 + pow(_ScanLineJitter, 3.0) * 0.05;\n  float verticalJump = _VerticalJump;\n  float verticalJumpTime = time_20 * verticalJump;\n  float horizontalShake = _HorizontalShake * 0.2;\n  float colorDrift = _ColorDrift * 0.04;\n  float time = time_20 * 606.11;\n  v_scanLineJitter = vec4(sl_disp, sl_thresh, abs(verticalJump), verticalJumpTime);\n  v_colorDrift = vec4(colorDrift, horizontalShake, time, time_20);\n}","frag":"\nprecision highp float;\nuniform mediump vec4 cc_screenSize;\n#ifndef COMMON_INCLUDE\n#define COMMON_INCLUDE\n#ifndef HLSL_FUNCTIONS_GLSL\n#define HLSL_FUNCTIONS_GLSL\n#define lerp mix\n#define frac fract\n#define fmod mod\n#define float2 vec2\n#define float3 vec3\n#define float4 vec4\n#define float2x2 mat2\n#define float3x3 mat3\n#define float4x4 mat4\n#define _ScreenParams cc_screenSize;\n#endif\nfloat nrand(float x, float y) {\n  return fract(sin(dot(vec2(x, y), vec2(12.9898, 78.233))) * 43758.5453);\n}\n#endif\n#ifndef COLOR_INCLUDE\n#define COLOR_INCLUDE\n#ifndef HLSL_FUNCTIONS_GLSL\n#define HLSL_FUNCTIONS_GLSL\n#define lerp mix\n#define frac fract\n#define fmod mod\n#define float2 vec2\n#define float3 vec3\n#define float4 vec4\n#define float2x2 mat2\n#define float3x3 mat3\n#define float4x4 mat4\n#define _ScreenParams cc_screenSize;\n#endif\n#endif\n#ifndef HLSL_FUNCTIONS_GLSL\n#define HLSL_FUNCTIONS_GLSL\n#define lerp mix\n#define frac fract\n#define fmod mod\n#define float2 vec2\n#define float3 vec3\n#define float4 vec4\n#define float2x2 mat2\n#define float3x3 mat3\n#define float4x4 mat4\n#define _ScreenParams cc_screenSize;\n#endif\nvarying vec2 v_uv;\nvarying vec4 v_scanLineJitter;\nvarying vec4 v_colorDrift;\nuniform sampler2D inputTexture;\nvoid main() {\n  float sl_disp = v_scanLineJitter.x;\n  float sl_thresh = v_scanLineJitter.y;\n  float verticalJump = v_scanLineJitter.z;\n  float verticalJumpTime = v_scanLineJitter.w;\n  float colorDrift = v_colorDrift.x;\n  float horizontalShake = v_colorDrift.y;\n  float time = v_colorDrift.z;\n  float time_20 = v_colorDrift.w;\n  float u = v_uv.x;\n  float v = v_uv.y;\n  float jitter = nrand(v, time_20) * 2.0 - 1.0;\n  jitter *= step(sl_thresh, abs(jitter)) * sl_disp;\n  float jump = mix(v, fract(v + verticalJumpTime), verticalJump);\n  float shake = (nrand(time_20, 2.0) - 0.5) * horizontalShake;\n  float drift = sin(jump + time) * colorDrift;\n  vec4 src1 = texture2D(inputTexture, fract(vec2(u + jitter + shake, jump)));\n  vec4 src2 = texture2D(inputTexture, fract(vec2(u + jitter + shake + drift, jump)));\n  vec4 color = vec4(src1.r, src2.g, src1.b, src1.a);\n  gl_FragColor = vec4(color.rgb,1);\n}"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"locals":{"blocks":[],"samplerTextures":[],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":44,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":44}},"defines":[{"name":"USE_INSTANCING","type":"boolean"},{"name":"CC_USE_SKINNING","type":"boolean"},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean"},{"name":"CC_USE_LIGHTMAP","type":"boolean"},{"name":"CC_USE_REFLECTION_PROBE","type":"boolean"},{"name":"CC_RECEIVE_SHADOW","type":"boolean"},{"name":"CC_USE_LIGHT_PROBE","type":"boolean"},{"name":"CC_USE_MORPH","type":"boolean"}]}],[{"passes":[{"pass":"post-process","program":"../Shaders/GlitchArt|vs|fs","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":0}]},"depthStencilState":{"depthTest":false,"depthWrite":false}}]}]]],0,0,[],[],[]],[[[1,"GlitchArt",[{}],[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{}]]],0,0,[0],[0],[0]]]]
